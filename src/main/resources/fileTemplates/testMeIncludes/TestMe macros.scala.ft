#parse("TestMe common macros.java")
################## Global vars ###############
#set($scReplacementTypesStatic = {
    "java.util.Collection": "[<VAL>]",
    "java.util.Deque": "new LinkedList([<VAL>])",
    "java.util.List": "[<VAL>]",
    "java.util.Map": "[<VAL>:<VAL>]",
    "java.util.NavigableMap": "new java.util.TreeMap([<VAL>:<VAL>])",
    "java.util.NavigableSet": "new java.util.TreeSet([<VAL>])",
    "java.util.Queue": "new java.util.LinkedList<TYPES>([<VAL>])",
    "java.util.RandomAccess": "new java.util.Vector([<VAL>])",
    "java.util.Set": "[<VAL>] as java.util.Set<TYPES>",
    "java.util.SortedSet": "[<VAL>] as java.util.SortedSet<TYPES>",
    "java.util.LinkedList": "new java.util.LinkedList<TYPES>([<VAL>])",
    "java.util.ArrayList": "[<VAL>]",
    "java.util.HashMap": "[<VAL>:<VAL>]",
    "java.util.TreeMap": "new java.util.TreeMap<TYPES>([<VAL>:<VAL>])",
    "java.util.LinkedList": "new java.util.LinkedList<TYPES>([<VAL>])",
    "java.util.Vector": "new java.util.Vector([<VAL>])",
    "java.util.HashSet": "[<VAL>] as java.util.HashSet",
    "java.util.Stack": "new java.util.Stack<TYPES>(){{push(<VAL>)}}",
    "java.util.LinkedHashMap": "[<VAL>:<VAL>]",
    "java.util.TreeSet": "[<VAL>] as java.util.TreeSet",

    "scala.Option": "Some(<VAL>)",
    "scala.collection.immutable.Map": "Map(<VAL> -> <VAL>)",
    "scala.Map": "Map(<VAL> -> <VAL>)",
    "scala.collection.immutable.Set": "Set(<VAL>)",
    "scala.Set": "Set(<VAL>)",
    "scala.collection.immutable.List": "List(<VAL>)",
    "scala.collection.Traversable": "List(<VAL>)",
    "scala.collection.TraversableOnce": "List(<VAL>)",
    "scala.collection.Iterable": "List(<VAL>)",
    "scala.collection.Seq": "List(<VAL>)",
    "scala.collection.mutable.Seq": "mutable.ArrayBuffer(<VAL>)",
    "scala.collection.mutable.Set": "mutable.Set(<VAL>)",
    "scala.collection.mutable.Map": "mutable.Map(<VAL> -> <VAL>)",
    "scala.util.Either": "Left(<VAL>)",
    "scala.util.Left": "Left(<VAL>)",
    "scala.util.Right": "Right(<VAL>)",
    "scala.List": "List(<VAL>)",
    "scala.Traversable": "List(<VAL>)",
    "scala.TraversableOnce": "List(<VAL>)",
    "scala.Iterable": "List(<VAL>)",
    "scala.Tuple1": "(<VAL>)",
    "scala.Tuple2": "(<VAL>,<VAL>)",
    "scala.Tuple3": "(<VAL>,<VAL>,<VAL>)",
    "scala.Tuple4": "(<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple5": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple6": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple7": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple8": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple9": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple10": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple11": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple12": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple13": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)"
})
#set($scReplacementTypes = $scReplacementTypesStatic.clone())
#set($scReplacementTypesForReturn = $scReplacementTypesStatic.clone())
#foreach($javaFutureType in $TestSubjectUtils.javaFutureTypes)
#evaluate(${scReplacementTypes.put($javaFutureType,"java.util.concurrent.CompletableFuture.completedFuture(<VAL>)")})
#end
#foreach($scalaFutureType in $TestSubjectUtils.scalaFutureTypes)
#evaluate(${scReplacementTypes.put($scalaFutureType,"scala.concurrent.Future.successful(<VAL>)")})
#end
#foreach($javaFutureType in $TestSubjectUtils.javaFutureTypes)
#evaluate(${scReplacementTypesForReturn.put($javaFutureType,"<VAL>")})
#end
#foreach($scalaFutureType in $TestSubjectUtils.scalaFutureTypes)
#evaluate(${scReplacementTypesForReturn.put($scalaFutureType,"<VAL>")})
#end
#set($scDefaultTypeValues = {
    "byte": "(byte)0",
    "short": "(short)0",
    "int": "1",
    "long": "0l",
    "float": "0f",
    "double": "0d",
    "char": "(char)'a'",
    "boolean": "true",
    "java.lang.Byte": """00110"" as Byte",
    "java.lang.Short": "(short)0",
    "java.lang.Integer": "0",
    "java.lang.Long": "1l",
    "java.lang.Float": "1.1f",
    "java.lang.Double": "0d",
    "java.lang.Character": "'a'",
    "java.lang.Boolean": "Boolean.TRUE",
    "java.math.BigDecimal": "0 as java.math.BigDecimal",
    "java.math.BigInteger": "0g",
    "java.util.Date": "new java.util.GregorianCalendar($YEAR, java.util.Calendar.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC, $HOUR_NUMERIC, $MINUTE_NUMERIC).getTime()",
    "java.time.LocalDate": "java.time.LocalDate.of($YEAR, java.time.Month.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC)",
    "java.time.LocalDateTime": "java.time.LocalDateTime.of($YEAR, java.time.Month.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC, $HOUR_NUMERIC, $MINUTE_NUMERIC, $SECOND_NUMERIC)",
    "java.time.LocalTime": "java.time.LocalTime.of($HOUR_NUMERIC, $MINUTE_NUMERIC, $SECOND_NUMERIC)",
    "java.time.Instant": "java.time.LocalDateTime.of($YEAR, java.time.Month.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC, $HOUR_NUMERIC, $MINUTE_NUMERIC, $SECOND_NUMERIC).toInstant(java.time.ZoneOffset.UTC)",
    "java.io.File": "new File(getClass().getResource(""/$PACKAGE_NAME.replace('.','/')/PleaseReplaceMeWithTestFile.txt"").getFile())",
    "java.lang.Class": "Class.forName(""$TESTED_CLASS.canonicalName"")",

    "scala.Byte": """00110"" as Byte",
    "scala.Short": "2",
    "scala.Int": "1",
    "scala.Long": "123456789",
    "scala.Float": "1.1f",
    "scala.Double": "11223344.53",
    "scala.Char": "a",
    "scala.Boolean": "true",
    "scala.math.BigDecimal": "2.44",
    "scala.concurrent.ExecutionContext": "scala.concurrent.ExecutionContext.Implicits.global"
})
##
##
################## Macros #####################
#macro(scRenderTestSubjectInit $testedClass $hasMocks $constructor)
#if($constructor)
    #set($ctorParams = ${constructor.methodParams})
#end
    val $StringUtils.deCapitalizeFirstLetter($testedClass.name) = new ${testedClass.name}(#scRenderCtorParams($ctorParams))
#end
##
#macro(scRenderMockedParams $constructor)
#if($constructor)
#set($ctorParams = ${constructor.methodParams})
#foreach($param in $ctorParams)
    #if($MockitoMockBuilder.isMockable($param, $scDefaultTypeValues))
    val $param.name: $param.type.canonicalName = mock[$param.type.canonicalName]
    ##elseif($MockitoMockBuilder.isMockExpected($field))
    ##    $MockitoMockBuilder.getImmockabiliyReason("//",$param) //not supported yet for scala
    #end
#end
#end
#end
##
#macro(scRenderCtorParams $ctorParams)
#foreach($param in $ctorParams)
#if($foreach.count>1), #end
#if($MockitoMockBuilder.isMockable($param, $scDefaultTypeValues))$param.name#{else}$TestBuilder.renderInitType($param.type,"$param.name",$scReplacementTypes,$scDefaultTypeValues)#end
#end
#end
##
#macro(scRenderAssert $method)
#if($TestSubjectUtils.isJavaFuture($method.returnType))result.get()#elseif($TestSubjectUtils.isScalaFuture($method.returnType))Await.result(result, 10.seconds)#{else}result#end === $TestBuilder.renderReturnParam($method,$method.returnType,"replaceMeWithExpectedResult",$scReplacementTypesForReturn,$scDefaultTypeValues)
#end
##
#macro(scRenderMethodCall $method,$testedClassName)
val result = #if($method.static)$testedClassName#{else}$StringUtils.deCapitalizeFirstLetter($testedClassName)#end.${method.name}#if($method.methodParams.size()>0)($TestBuilder.renderMethodParams($method,$scReplacementTypes,$scDefaultTypeValues))#end

#end
##
#macro(scRenderParameterizedMethodCall $method,$testedClassName $methodClassParamsStr)
#if($method.static)$testedClassName#{else}$StringUtils.deCapitalizeFirstLetter($testedClassName)#end.${method.name}($methodClassParamsStr)##
#end
##
#macro(scRenderMockStubs $method $primaryCtor)
#if($primaryCtor)
#foreach($param in $primaryCtor.methodParams)
#if($MockitoMockBuilder.isMockable($param, $scDefaultTypeValues))
#foreach($paramMethod in $param.type.methods)
#if($paramMethod.returnType && $paramMethod.returnType.name !="void" && $TestSubjectUtils.isMethodCalled($paramMethod,$method))
        $param.name.${paramMethod.name}($MockitoMockBuilder.buildMockArgsMatchers(${paramMethod.methodParams},"Scala")) returns $TestBuilder.renderReturnParam($method,$paramMethod.returnType,"${paramMethod.name}Response",$scReplacementTypes,$scDefaultTypeValues)
#end
#end
#end
#end
#end
#end