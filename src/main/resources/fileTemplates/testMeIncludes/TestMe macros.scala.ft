#parse("TestMe common macros.java")
################## Global vars ###############
#set($scReplacementTypesStatic = {

    "scala.Option": "Some(<VAL>)",
    "scala.collection.immutable.Map": "Map(<VAL> -> <VAL>)",
    "scala.Map": "Map(<VAL> -> <VAL>)",
    "scala.collection.immutable.Set": "Set(<VAL>)",
    "scala.Set": "Set(<VAL>)",
    "scala.collection.immutable.List": "List(<VAL>)",
    "scala.collection.Traversable": "List(<VAL>)",
    "scala.collection.TraversableOnce": "List(<VAL>)",
    "scala.collection.Iterable": "List(<VAL>)",
    "scala.collection.Seq": "List(<VAL>)",
    "scala.collection.mutable.Seq": "mutable.ArrayBuffer(<VAL>)",
    "scala.collection.mutable.Set": "mutable.Set(<VAL>)",
    "scala.collection.mutable.Map": "mutable.Map(<VAL> -> <VAL>)",
    "scala.util.Either": "Left(<VAL>)",
    "scala.util.Left": "Left(<VAL>)",
    "scala.util.Right": "Right(<VAL>)",
    "scala.List": "List(<VAL>)",
    "scala.Traversable": "List(<VAL>)",
    "scala.TraversableOnce": "List(<VAL>)",
    "scala.Iterable": "List(<VAL>)",
    "scala.Tuple1": "(<VAL>)",
    "scala.Tuple2": "(<VAL>,<VAL>)",
    "scala.Tuple3": "(<VAL>,<VAL>,<VAL>)",
    "scala.Tuple4": "(<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple5": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple6": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple7": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple8": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple9": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple10": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple11": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple12": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",
    "scala.Tuple13": "(<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>,<VAL>)",


    "java.util.Collection": "java.util.Arrays.asList<VAL>([<VAL>])",
    "java.util.Deque": "new java.util.LinkedList<VAL>(java.util.Arrays.asList([<VAL>]))",
    "java.util.List": "java.util.Arrays.asList<VAL>([<VAL>])",
    "java.util.Map": "new java.util.HashMap<VAL>(){{put([<VAL>],[<VAL>]);}}",
    "java.util.NavigableMap": "new java.util.TreeMap<VAL>(new java.util.HashMap<VAL>(){{put([<VAL>],[<VAL>]);}})",
    "java.util.NavigableSet": "new java.util.TreeSet<VAL>(java.util.Arrays.asList([<VAL>]))",
    "java.util.Queue": "new java.util.LinkedList<VAL>(java.util.Arrays.asList([<VAL>]))",
    "java.util.RandomAccess": "new java.util.Vector(java.util.Arrays.asList([<VAL>]))",
    "java.util.Set": "new java.util.HashSet<VAL>(java.util.Arrays.asList([<VAL>]))",
    "java.util.SortedSet": "new java.util.TreeSet<VAL>(java.util.Arrays.asList([<VAL>]))",
    "java.util.LinkedList": "new java.util.LinkedList<VAL>(java.util.Arrays.asList([<VAL>]))",
    "java.util.ArrayList": "new java.util.ArrayList<VAL>(java.util.Arrays.asList([<VAL>]))",
    "java.util.HashMap": "new java.util.HashMap<VAL>(){{put([<VAL>],[<VAL>]);}}",
    "java.util.TreeMap": "new java.util.TreeMap<VAL>(new java.util.HashMap<VAL>(){{put([<VAL>],[<VAL>]);}})",
    "java.util.LinkedList": "new java.util.LinkedList<VAL>(java.util.Arrays.asList([<VAL>]))",
    "java.util.Vector": "new java.util.Vector(java.util.Arrays.asList([<VAL>]))",
    "java.util.HashSet": "new java.util.HashSet<VAL>(java.util.Arrays.asList([<VAL>]))",
    "java.util.Stack": "new java.util.Stack<VAL>(){{push([<VAL>]);}}",
    "java.util.TreeSet": "new java.util.TreeSet<VAL>(java.util.Arrays.asList([<VAL>]))",


    "Collection": "java.util.Arrays.<VAL>asList([<VAL>])",
    "Deque": "new java.util.LinkedList<VAL>(java.util.Arrays.asList([<VAL>]))",
    "List": "java.util.Arrays.<VAL>asList([<VAL>])",
    "Map": "new java.util.HashMap<VAL>(){{put([<VAL>],[<VAL>]);}}",
    "NavigableMap": "new java.util.TreeMap<VAL>(new java.util.HashMap<VAL>(){{put([<VAL>],[<VAL>]);}})",
    "NavigableSet": "new java.util.TreeSet<VAL>(java.util.Arrays.asList([<VAL>]))",
    "Queue": "new java.util.LinkedList<VAL>(java.util.Arrays.asList([<VAL>]))",
    "RandomAccess": "new java.util.Vector(java.util.Arrays.asList([<VAL>]))",
    "Set": "new java.util.HashSet<VAL>(java.util.Arrays.asList([<VAL>]))",
    "SortedSet": "new java.util.TreeSet<VAL>(java.util.Arrays.asList([<VAL>]))",
    "LinkedList": "new java.util.LinkedList<VAL>(java.util.Arrays.asList([<VAL>]))",
    "ArrayList": "new java.util.ArrayList<VAL>(java.util.Arrays.asList([<VAL>]))",
    "HashMap": "new java.util.HashMap<VAL>(){{put([<VAL>],[<VAL>]);}}",
    "TreeMap": "new java.util.TreeMap<VAL>(new java.util.HashMap<VAL>(){{put([<VAL>],[<VAL>]);}})",
    "LinkedList": "new java.util.LinkedList<VAL>(java.util.Arrays.asList([<VAL>]))",
    "Vector": "new java.util.Vector(java.util.Arrays.asList([<VAL>]))",
    "HashSet": "new java.util.HashSet<VAL>(java.util.Arrays.asList([<VAL>]))",
    "Stack": "new java.util.Stack<VAL>(){{push([<VAL>]);}}",
    "TreeSet": "new java.util.TreeSet<VAL>(java.util.Arrays.asList([<VAL>]))"
})
#set($scReplacementTypes = $scReplacementTypesStatic.clone())
#set($scReplacementTypesForReturn = $scReplacementTypesStatic.clone())
#foreach($javaFutureType in $TestSubjectUtils.javaFutureTypes)
#evaluate(${scReplacementTypes.put($javaFutureType,"java.util.concurrent.CompletableFuture.completedFuture(<<VAL>>)")})
#end
#foreach($scalaFutureType in $TestSubjectUtils.scalaFutureTypes)
#evaluate(${scReplacementTypes.put($scalaFutureType,"scala.concurrent.Future.successful(<VAL>)")})
#end
#foreach($javaFutureType in $TestSubjectUtils.javaFutureTypes)
#evaluate(${scReplacementTypesForReturn.put($javaFutureType,"<VAL>")})
#end
#foreach($scalaFutureType in $TestSubjectUtils.scalaFutureTypes)
#evaluate(${scReplacementTypesForReturn.put($scalaFutureType,"<VAL>")})
#end
#set($scDefaultTypeValues = {
    "byte": "64.toByte",
    "short": "21.toShort",
    "int": "1",
    "long": "12345l",
    "float": "1.1f",
    "double": "100d",
    "char": "'c'",
    "boolean": "true",
    "java.lang.Byte": "64.toByte",
    "java.lang.Short": "21.toShort",
    "java.lang.Integer": "1",
    "java.lang.Long": "12345l",
    "java.lang.Float": "1.1f",
    "java.lang.Double": "100d",
    "java.lang.Character": "'c'",
    "java.lang.Boolean": "true",
    "java.math.BigInteger": "BigInt(123123).bigInteger",
    "java.math.BigDecimal": "BigDecimal(2.44).bigDecimal",
    "java.util.Date": "new java.util.GregorianCalendar($YEAR, java.util.Calendar.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC, $HOUR_NUMERIC, $MINUTE_NUMERIC).getTime",
    "java.time.LocalDate": "java.time.LocalDate.of($YEAR, java.time.Month.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC)",
    "java.time.LocalDateTime": "java.time.LocalDateTime.of($YEAR, java.time.Month.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC, $HOUR_NUMERIC, $MINUTE_NUMERIC, $SECOND_NUMERIC)",
    "java.time.LocalTime": "java.time.LocalTime.of($HOUR_NUMERIC, $MINUTE_NUMERIC, $SECOND_NUMERIC)",
    "java.time.Instant": "java.time.LocalDateTime.of($YEAR, java.time.Month.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC, $HOUR_NUMERIC, $MINUTE_NUMERIC, $SECOND_NUMERIC).toInstant(java.time.ZoneOffset.UTC)",
    "java.io.File": "new File(getClass().getResource(""/$PACKAGE_NAME.replace('.','/')/PleaseReplaceMeWithTestFile.txt"").getFile())",
    "java.lang.Class": "Class.forName(""$TESTED_CLASS.canonicalName"")",

    "scala.Byte": "64.toByte",
    "scala.Short": "21.toShort",
    "scala.Int": "1",
    "scala.Long": "12345l",
    "scala.Float": "1.1f",
    "scala.Double": "100d",
    "scala.Char": "'c'",
    "scala.Boolean": "true",
    "scala.math.BigInt": "BigInt(123123).bigInteger",
    "scala.math.BigDecimal": "BigDecimal(2.44).bigDecimal",

    "scala.concurrent.ExecutionContext": "scala.concurrent.ExecutionContext.Implicits.global",

    "Byte": "64.toByte",
    "Short": "21.toShort",
    "Integer": "1",
    "Long": "12345l",
    "Float": "1.1f",
    "Double": "100d",
    "Character": "'c'",
    "Boolean": "true",
    "BigInteger": "BigInt(123123).bigInteger",
    "BigDecimal": "BigDecimal(2.44).bigDecimal",
    "Date": "new java.util.GregorianCalendar($YEAR, java.util.Calendar.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC, $HOUR_NUMERIC, $MINUTE_NUMERIC).getTime",
    "LocalDate": "java.time.LocalDate.of($YEAR, java.time.Month.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC)",
    "LocalDateTime": "java.time.LocalDateTime.of($YEAR, java.time.Month.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC, $HOUR_NUMERIC, $MINUTE_NUMERIC, $SECOND_NUMERIC)",
    "LocalTime": "java.time.LocalTime.of($HOUR_NUMERIC, $MINUTE_NUMERIC, $SECOND_NUMERIC)",
    "Instant": "java.time.LocalDateTime.of($YEAR, java.time.Month.$MONTH_NAME_EN.toUpperCase(), $DAY_NUMERIC, $HOUR_NUMERIC, $MINUTE_NUMERIC, $SECOND_NUMERIC).toInstant(java.time.ZoneOffset.UTC)"

})
##
##
################## Macros #####################
#macro(scRenderTestSubjectInit $testedClass $hasMocks $constructor)
#if($constructor)
    #set($ctorParams = ${constructor.methodParams})
#end
    val $StringUtils.deCapitalizeFirstLetter($testedClass.name) = new ${testedClass.name}(#scRenderCtorParams($ctorParams))
#end
##
#macro(scRenderMockedParams $constructor)
#if($constructor)
#set($ctorParams = ${constructor.methodParams})
#foreach($param in $ctorParams)
    #if($MockitoMockBuilder.isMockable($param, $scDefaultTypeValues))
    val $param.name: $param.type.canonicalName = mock[$param.type.canonicalName]
    ##elseif($MockitoMockBuilder.isMockExpected($field))
    ##    $MockitoMockBuilder.getImmockabiliyReason("//",$param) //not supported yet for scala
    #end
#end
#end
#end
##
#macro(scRenderCtorParams $ctorParams)
#foreach($param in $ctorParams)
#if($foreach.count>1), #end
#if($MockitoMockBuilder.isMockable($param, $scDefaultTypeValues))$param.name#{else}$TestBuilder.renderInitType($param.type,"$param.name",$scReplacementTypes,$scDefaultTypeValues)#end
#end
#end
##
#macro(scRenderAssert $method)
#if($TestSubjectUtils.isJavaFuture($method.returnType))result.get()#elseif($TestSubjectUtils.isScalaFuture($method.returnType))Await.result(result, 10.seconds)#{else}result#end === $TestBuilder.renderReturnParam($method,$method.returnType,"replaceMeWithExpectedResult",$scReplacementTypesForReturn,$scDefaultTypeValues)
#end
##
#macro(scRenderMethodCall $method,$testedClass)
#set($testedClassName = $testedClass.name)
val result = #if($method.static || $TESTED_CLASS.isStatic())$StringUtils.removeSuffix($testedClassName,"$")#{else}$StringUtils.deCapitalizeFirstLetter($testedClassName)#end.${method.name}#if($method.methodParams.size()>0)($TestBuilder.renderMethodParams($method,$scReplacementTypes,$scDefaultTypeValues))#end

#end
##
#macro(scRenderParameterizedMethodCall $method,$testedClassName $methodClassParamsStr)
#if($method.static)$StringUtils.removeSuffix($testedClassName,"$")#{else}$StringUtils.deCapitalizeFirstLetter($testedClassName)#end.${method.name}($methodClassParamsStr)##
#end
##
#macro(scRenderMockStubs $method $primaryCtor)
#if($primaryCtor)
#foreach($param in $primaryCtor.methodParams)
#if($MockitoMockBuilder.isMockable($param, $scDefaultTypeValues))
#foreach($paramMethod in $param.type.methods)
#if($paramMethod.returnType && $paramMethod.returnType.name !="void" && $TestSubjectUtils.isMethodCalled($paramMethod,$method))
        $param.name.${paramMethod.name}($MockitoMockBuilder.buildMockArgsMatchers(${paramMethod.methodParams},"Scala")) returns $TestBuilder.renderReturnParam($method,$paramMethod.returnType,"${paramMethod.name}Response",$scReplacementTypes,$scDefaultTypeValues)
#end
#end
#end
#end
#end
#end